// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod db {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum DriveItem {
        NONE = 0,
        File = 1,
        Dir = 2,
    }

    pub const ENUM_MIN_DRIVE_ITEM: u8 = 0;
    pub const ENUM_MAX_DRIVE_ITEM: u8 = 2;

    impl<'a> flatbuffers::Follow<'a> for DriveItem {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for DriveItem {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const DriveItem;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const DriveItem;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for DriveItem {
        type Output = DriveItem;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<DriveItem>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_DRIVE_ITEM: [DriveItem; 3] =
        [DriveItem::NONE, DriveItem::File, DriveItem::Dir];

    #[allow(non_camel_case_types)]
    pub const ENUM_NAMES_DRIVE_ITEM: [&'static str; 3] = ["NONE", "File", "Dir"];

    pub fn enum_name_drive_item(e: DriveItem) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_DRIVE_ITEM[index as usize]
    }

    pub struct DriveItemUnionTableOffset {}
    pub enum FileOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct File<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for File<'a> {
        type Inner = File<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> File<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            File { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FileArgs<'args>,
        ) -> flatbuffers::WIPOffset<File<'bldr>> {
            let mut builder = FileBuilder::new(_fbb);
            builder.add_modified_time(args.modified_time);
            builder.add_size_(args.size_);
            if let Some(x) = args.md5 {
                builder.add_md5(x);
            }
            builder.finish()
        }

        pub const VT_MD5: flatbuffers::VOffsetT = 4;
        pub const VT_SIZE_: flatbuffers::VOffsetT = 6;
        pub const VT_MODIFIED_TIME: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn md5(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    File::VT_MD5,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn size_(&self) -> u64 {
            self._tab.get::<u64>(File::VT_SIZE_, Some(0)).unwrap()
        }
        #[inline]
        pub fn modified_time(&self) -> u64 {
            self._tab
                .get::<u64>(File::VT_MODIFIED_TIME, Some(0))
                .unwrap()
        }
    }

    pub struct FileArgs<'a> {
        pub md5: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub size_: u64,
        pub modified_time: u64,
    }
    impl<'a> Default for FileArgs<'a> {
        #[inline]
        fn default() -> Self {
            FileArgs {
                md5: None,
                size_: 0,
                modified_time: 0,
            }
        }
    }
    pub struct FileBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FileBuilder<'a, 'b> {
        #[inline]
        pub fn add_md5(&mut self, md5: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_MD5, md5);
        }
        #[inline]
        pub fn add_size_(&mut self, size_: u64) {
            self.fbb_.push_slot::<u64>(File::VT_SIZE_, size_, 0);
        }
        #[inline]
        pub fn add_modified_time(&mut self, modified_time: u64) {
            self.fbb_
                .push_slot::<u64>(File::VT_MODIFIED_TIME, modified_time, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FileBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<File<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum DirOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Dir<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Dir<'a> {
        type Inner = Dir<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Dir<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Dir { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DirArgs<'args>,
        ) -> flatbuffers::WIPOffset<Dir<'bldr>> {
            let mut builder = DirBuilder::new(_fbb);
            if let Some(x) = args.items {
                builder.add_items(x);
            }
            builder.finish()
        }

        pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn items(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DirItem<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<DirItem<'a>>>,
            >>(Dir::VT_ITEMS, None)
        }
    }

    pub struct DirArgs<'a> {
        pub items: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DirItem<'a>>>,
            >,
        >,
    }
    impl<'a> Default for DirArgs<'a> {
        #[inline]
        fn default() -> Self {
            DirArgs { items: None }
        }
    }
    pub struct DirBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DirBuilder<'a, 'b> {
        #[inline]
        pub fn add_items(
            &mut self,
            items: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DirItem<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Dir::VT_ITEMS, items);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DirBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DirBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Dir<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum DirItemOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct DirItem<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DirItem<'a> {
        type Inner = DirItem<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> DirItem<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DirItem { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DirItemArgs<'args>,
        ) -> flatbuffers::WIPOffset<DirItem<'bldr>> {
            let mut builder = DirItemBuilder::new(_fbb);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(DirItem::VT_NAME, None)
        }
        #[inline]
        pub fn id(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(DirItem::VT_ID, None)
        }
    }

    pub struct DirItemArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for DirItemArgs<'a> {
        #[inline]
        fn default() -> Self {
            DirItemArgs {
                name: None,
                id: None,
            }
        }
    }
    pub struct DirItemBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DirItemBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DirItem::VT_NAME, name);
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(DirItem::VT_ID, id);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DirItemBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DirItemBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DirItem<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum ReverseItemOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct ReverseItem<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReverseItem<'a> {
        type Inner = ReverseItem<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> ReverseItem<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReverseItem { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReverseItemArgs<'args>,
        ) -> flatbuffers::WIPOffset<ReverseItem<'bldr>> {
            let mut builder = ReverseItemBuilder::new(_fbb);
            if let Some(x) = args.parent_ids {
                builder.add_parent_ids(x);
            }
            builder.finish()
        }

        pub const VT_PARENT_IDS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn parent_ids(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
            >>(ReverseItem::VT_PARENT_IDS, None)
        }
    }

    pub struct ReverseItemArgs<'a> {
        pub parent_ids: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for ReverseItemArgs<'a> {
        #[inline]
        fn default() -> Self {
            ReverseItemArgs { parent_ids: None }
        }
    }
    pub struct ReverseItemBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReverseItemBuilder<'a, 'b> {
        #[inline]
        pub fn add_parent_ids(
            &mut self,
            parent_ids: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ReverseItem::VT_PARENT_IDS,
                parent_ids,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReverseItemBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReverseItemBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReverseItem<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }
} // pub mod Db
