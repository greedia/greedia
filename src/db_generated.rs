// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum DriveItemData {
  NONE = 0,
  FileItem = 1,
  Dir = 2,

}

pub const ENUM_MIN_DRIVE_ITEM_DATA: u8 = 0;
pub const ENUM_MAX_DRIVE_ITEM_DATA: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for DriveItemData {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for DriveItemData {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const DriveItemData;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const DriveItemData;
    unsafe { *p }
  }
}

impl flatbuffers::Push for DriveItemData {
    type Output = DriveItemData;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<DriveItemData>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DRIVE_ITEM_DATA:[DriveItemData; 3] = [
  DriveItemData::NONE,
  DriveItemData::FileItem,
  DriveItemData::Dir
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_DRIVE_ITEM_DATA:[&'static str; 3] = [
    "NONE",
    "FileItem",
    "Dir"
];

pub fn enum_name_drive_item_data(e: DriveItemData) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_DRIVE_ITEM_DATA[index as usize]
}

pub struct DriveItemDataUnionTableOffset {}
pub enum DriveItemOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DriveItem<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DriveItem<'a> {
    type Inner = DriveItem<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DriveItem<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DriveItem {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DriveItemArgs<'args>) -> flatbuffers::WIPOffset<DriveItem<'bldr>> {
      let mut builder = DriveItemBuilder::new(_fbb);
      if let Some(x) = args.data { builder.add_data(x); }
      if let Some(x) = args.id { builder.add_id(x); }
      builder.add_data_type(args.data_type);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DriveItem::VT_ID, None)
  }
  #[inline]
  pub fn data_type(&self) -> DriveItemData {
    self._tab.get::<DriveItemData>(DriveItem::VT_DATA_TYPE, Some(DriveItemData::NONE)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DriveItem::VT_DATA, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_file_item(&self) -> Option<FileItem<'a>> {
    if self.data_type() == DriveItemData::FileItem {
      self.data().map(|u| FileItem::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn data_as_dir(&self) -> Option<Dir<'a>> {
    if self.data_type() == DriveItemData::Dir {
      self.data().map(|u| Dir::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct DriveItemArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub data_type: DriveItemData,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DriveItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        DriveItemArgs {
            id: None,
            data_type: DriveItemData::NONE,
            data: None,
        }
    }
}
pub struct DriveItemBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DriveItemBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DriveItem::VT_ID, id);
  }
  #[inline]
  pub fn add_data_type(&mut self, data_type: DriveItemData) {
    self.fbb_.push_slot::<DriveItemData>(DriveItem::VT_DATA_TYPE, data_type, DriveItemData::NONE);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DriveItem::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DriveItemBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DriveItemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DriveItem<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FileItemOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FileItem<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FileItem<'a> {
    type Inner = FileItem<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FileItem<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FileItem {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FileItemArgs<'args>) -> flatbuffers::WIPOffset<FileItem<'bldr>> {
      let mut builder = FileItemBuilder::new(_fbb);
      builder.add_modified_time(args.modified_time);
      builder.add_size_(args.size_);
      if let Some(x) = args.md5 { builder.add_md5(x); }
      builder.finish()
    }

    pub const VT_MD5: flatbuffers::VOffsetT = 4;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 6;
    pub const VT_MODIFIED_TIME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn md5(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(FileItem::VT_MD5, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn size_(&self) -> u64 {
    self._tab.get::<u64>(FileItem::VT_SIZE_, Some(0)).unwrap()
  }
  #[inline]
  pub fn modified_time(&self) -> u64 {
    self._tab.get::<u64>(FileItem::VT_MODIFIED_TIME, Some(0)).unwrap()
  }
}

pub struct FileItemArgs<'a> {
    pub md5: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub size_: u64,
    pub modified_time: u64,
}
impl<'a> Default for FileItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        FileItemArgs {
            md5: None,
            size_: 0,
            modified_time: 0,
        }
    }
}
pub struct FileItemBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FileItemBuilder<'a, 'b> {
  #[inline]
  pub fn add_md5(&mut self, md5: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FileItem::VT_MD5, md5);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: u64) {
    self.fbb_.push_slot::<u64>(FileItem::VT_SIZE_, size_, 0);
  }
  #[inline]
  pub fn add_modified_time(&mut self, modified_time: u64) {
    self.fbb_.push_slot::<u64>(FileItem::VT_MODIFIED_TIME, modified_time, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileItemBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FileItemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FileItem<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DirOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Dir<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Dir<'a> {
    type Inner = Dir<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Dir<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Dir {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DirArgs<'args>) -> flatbuffers::WIPOffset<Dir<'bldr>> {
      let mut builder = DirBuilder::new(_fbb);
      builder.add_modified_time(args.modified_time);
      if let Some(x) = args.items { builder.add_items(x); }
      builder.finish()
    }

    pub const VT_ITEMS: flatbuffers::VOffsetT = 4;
    pub const VT_MODIFIED_TIME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn items(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DirItem<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<DirItem<'a>>>>>(Dir::VT_ITEMS, None)
  }
  #[inline]
  pub fn modified_time(&self) -> u64 {
    self._tab.get::<u64>(Dir::VT_MODIFIED_TIME, Some(0)).unwrap()
  }
}

pub struct DirArgs<'a> {
    pub items: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<DirItem<'a >>>>>,
    pub modified_time: u64,
}
impl<'a> Default for DirArgs<'a> {
    #[inline]
    fn default() -> Self {
        DirArgs {
            items: None,
            modified_time: 0,
        }
    }
}
pub struct DirBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DirBuilder<'a, 'b> {
  #[inline]
  pub fn add_items(&mut self, items: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DirItem<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Dir::VT_ITEMS, items);
  }
  #[inline]
  pub fn add_modified_time(&mut self, modified_time: u64) {
    self.fbb_.push_slot::<u64>(Dir::VT_MODIFIED_TIME, modified_time, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DirBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DirBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Dir<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DirItemOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DirItem<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DirItem<'a> {
    type Inner = DirItem<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DirItem<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DirItem {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DirItemArgs<'args>) -> flatbuffers::WIPOffset<DirItem<'bldr>> {
      let mut builder = DirItemBuilder::new(_fbb);
      builder.add_inode(args.inode);
      if let Some(x) = args.id { builder.add_id(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_is_dir(args.is_dir);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_INODE: flatbuffers::VOffsetT = 8;
    pub const VT_IS_DIR: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DirItem::VT_NAME, None)
  }
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DirItem::VT_ID, None)
  }
  #[inline]
  pub fn inode(&self) -> u64 {
    self._tab.get::<u64>(DirItem::VT_INODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn is_dir(&self) -> bool {
    self._tab.get::<bool>(DirItem::VT_IS_DIR, Some(false)).unwrap()
  }
}

pub struct DirItemArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub inode: u64,
    pub is_dir: bool,
}
impl<'a> Default for DirItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        DirItemArgs {
            name: None,
            id: None,
            inode: 0,
            is_dir: false,
        }
    }
}
pub struct DirItemBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DirItemBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DirItem::VT_NAME, name);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DirItem::VT_ID, id);
  }
  #[inline]
  pub fn add_inode(&mut self, inode: u64) {
    self.fbb_.push_slot::<u64>(DirItem::VT_INODE, inode, 0);
  }
  #[inline]
  pub fn add_is_dir(&mut self, is_dir: bool) {
    self.fbb_.push_slot::<bool>(DirItem::VT_IS_DIR, is_dir, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DirItemBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DirItemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DirItem<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InodeNodeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InodeNode<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InodeNode<'a> {
    type Inner = InodeNode<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InodeNode<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InodeNode {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InodeNodeArgs<'args>) -> flatbuffers::WIPOffset<InodeNode<'bldr>> {
      let mut builder = InodeNodeBuilder::new(_fbb);
      if let Some(x) = args.item { builder.add_item(x); }
      builder.finish()
    }

    pub const VT_ITEM: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn item(&self) -> Option<DriveItem<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<DriveItem<'a>>>(InodeNode::VT_ITEM, None)
  }
}

pub struct InodeNodeArgs<'a> {
    pub item: Option<flatbuffers::WIPOffset<DriveItem<'a >>>,
}
impl<'a> Default for InodeNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        InodeNodeArgs {
            item: None,
        }
    }
}
pub struct InodeNodeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InodeNodeBuilder<'a, 'b> {
  #[inline]
  pub fn add_item(&mut self, item: flatbuffers::WIPOffset<DriveItem<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DriveItem>>(InodeNode::VT_ITEM, item);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InodeNodeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InodeNodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InodeNode<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ReverseAccessNodeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ReverseAccessNode<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReverseAccessNode<'a> {
    type Inner = ReverseAccessNode<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ReverseAccessNode<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReverseAccessNode {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReverseAccessNodeArgs<'args>) -> flatbuffers::WIPOffset<ReverseAccessNode<'bldr>> {
      let mut builder = ReverseAccessNodeBuilder::new(_fbb);
      builder.add_inode(args.inode);
      if let Some(x) = args.parent_inodes { builder.add_parent_inodes(x); }
      builder.finish()
    }

    pub const VT_INODE: flatbuffers::VOffsetT = 4;
    pub const VT_PARENT_INODES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn inode(&self) -> u64 {
    self._tab.get::<u64>(ReverseAccessNode::VT_INODE, Some(0)).unwrap()
  }
  #[inline]
  pub fn parent_inodes(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(ReverseAccessNode::VT_PARENT_INODES, None)
  }
}

pub struct ReverseAccessNodeArgs<'a> {
    pub inode: u64,
    pub parent_inodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u64>>>,
}
impl<'a> Default for ReverseAccessNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReverseAccessNodeArgs {
            inode: 0,
            parent_inodes: None,
        }
    }
}
pub struct ReverseAccessNodeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReverseAccessNodeBuilder<'a, 'b> {
  #[inline]
  pub fn add_inode(&mut self, inode: u64) {
    self.fbb_.push_slot::<u64>(ReverseAccessNode::VT_INODE, inode, 0);
  }
  #[inline]
  pub fn add_parent_inodes(&mut self, parent_inodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReverseAccessNode::VT_PARENT_INODES, parent_inodes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReverseAccessNodeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReverseAccessNodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReverseAccessNode<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ScanStateOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ScanState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScanState<'a> {
    type Inner = ScanState<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ScanState<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ScanState {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ScanStateArgs<'args>) -> flatbuffers::WIPOffset<ScanState<'bldr>> {
      let mut builder = ScanStateBuilder::new(_fbb);
      builder.add_last_modified_date(args.last_modified_date);
      if let Some(x) = args.last_page_token { builder.add_last_page_token(x); }
      builder.finish()
    }

    pub const VT_LAST_PAGE_TOKEN: flatbuffers::VOffsetT = 4;
    pub const VT_LAST_MODIFIED_DATE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn last_page_token(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ScanState::VT_LAST_PAGE_TOKEN, None)
  }
  #[inline]
  pub fn last_modified_date(&self) -> u64 {
    self._tab.get::<u64>(ScanState::VT_LAST_MODIFIED_DATE, Some(0)).unwrap()
  }
}

pub struct ScanStateArgs<'a> {
    pub last_page_token: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub last_modified_date: u64,
}
impl<'a> Default for ScanStateArgs<'a> {
    #[inline]
    fn default() -> Self {
        ScanStateArgs {
            last_page_token: None,
            last_modified_date: 0,
        }
    }
}
pub struct ScanStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ScanStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_last_page_token(&mut self, last_page_token: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ScanState::VT_LAST_PAGE_TOKEN, last_page_token);
  }
  #[inline]
  pub fn add_last_modified_date(&mut self, last_modified_date: u64) {
    self.fbb_.push_slot::<u64>(ScanState::VT_LAST_MODIFIED_DATE, last_modified_date, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ScanStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ScanStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScanState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

